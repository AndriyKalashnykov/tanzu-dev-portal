---
title:  "CF-for-k8s: Getting Started with Deploying CF-for-k8s locally on Kubernetes"
sortTitle: "cf-for-k8s"
weight: 2
topics:
- kubernetes
tags:
- cf-for-k8s
patterns:
- deployment
---

## Getting Started with CF-for-k8s: Deploying CF-for-k8s developer platform on Kubernetes

### What is cf-for-k8s?

[cf-for-k8s](https://github.com/cloudfoundry/cf-for-k8s.git) Cloud Foundry is an open source, multi-cloud application platform as a service governed by the Cloud Foundry Foundation, a 501 organization. The software was originally developed by VMware, transferred to Pivotal Software but brought back into VMware at the end of 2019 with VMware's purchase of Pivotal.

Cloud Foundry increases developer productivity, saving significant time and resources while making companies more competitive.

In this guide you'll deploy Cloud Foundry on Kubernetes locally.

### Before you begin
> You will need a few tools before begining, these tools will be automated by the script `bin/install-cf.sh` which takes ~10 mins to finish
- You will need `kubectl` to interact with your cluster [kubectl install instructions](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    * on mac 
        ```
        brew install kubectl
        # verify install 
        kubectl version --client
        ```
- KinD (Kubernetes in Docker) to instantiate your local cluster [Kind install instructions](https://kind.sigs.k8s.io/docs/user/quick-start/) 
    * on mac 
        ```
        brew install kind
        # verify install 
        kind version
        ```

- [Cloud Foundry CLI](https://docs.cloudfoundry.org/cf-cli/install-go-cli.html) (v6.50+) to talk to Cloud Foundry
    * on mac 
        ```
        brew install cloudfoundry/tap/cf-cli
        # verify install 
        cf version
        ```
- [Bosh CLI](https://bosh.io/docs/cli-v2-install/) the install script will use Bosh CLI to generate certificates, keys, and passwords so you don't kill a lot of time generatng them
- [kapp](https://k14s.io/#install) (v0.21.0+) will aid the script to deploy cf-for-k8s to your cluster
    * on mac 
        ```
        brew tap k14s/tap
        brew install ytt kapp
        kapp --version
        ```

- [`ytt`](https://k14s.io/#install) (v0.26.0+) will help the script create templates to deploy cf-for-k8s
    * on mac you should have this installed from the above command, to verify:
        ```
        ytt version
        ```
## Clone the CF for K8s repo
Clone the repo to preffered location and cd into it.
```
git clone https://github.com/cloudfoundry/cf-for-k8s.git

cd cf-for-k8s
```        

### Setup your local k8s cluster 
You will need a 5 node kuberntes cluster with a minimum of 4 CPU, 8GB memory per node
```
kind create cluster --config=./deploy/kind/cluster.yml
```
Now that you have a repo connected, you need to see what charts you have available to deploy.
```
$ helm search repo bitnami
NAME                            	CHART VERSION	APP VERSION            	DESCRIPTION
bitnami/bitnami-common          	0.0.8        	0.0.8                  	Chart with custom templates used in Bitnami cha...
bitnami/airflow                 	5.0.3        	1.10.9                 	Apache Airflow is a platform to programmaticall...
bitnami/apache                  	7.3.9        	2.4.41                 	Chart for Apache HTTP Server
---- Truncated ----
```
You can see a whole list of charts, but here's the first three. They show the name of the chart, the versions, and the descriptions. If you notice there's both a chart version and an app version. This is because a chart may be updated and changed separately from the underlying application it is deploying.

### Time to Deploy a Chart (Create a Release)

Now that you have helm configured with a repo, you can deploy a chart. In helm lingo that's called _creating a release_. In this example, you'll deploy a pretty simple one like nginx. You can supply a name for your app like you're going to do here (my app) or you can use the `--generate-name` CLI option to have helm generate one for you.
```yaml
$ helm install my-app bitnami/nginx
NAME: my-app
LAST DEPLOYED: Mon Mar 9 07:37:28 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Get the NGINX URL:

  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        Watch the status with: 'kubectl get svc --namespace default -w my-app-nginx'

  export SERVICE_IP=$(kubectl get svc --namespace default my-app-nginx --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")
  echo "NGINX URL: http://$SERVICE_IP/"
  ```

After your release is successfully created, you'll see an output like this with the name, namespace, status, etc. The `NOTES` section has specific information about your install–that's because it's generated by helm using a template too.

You can see what was deployed by using `kubectl`.
```
$ kubectl get all
NAME                                READY   STATUS    RESTARTS   AGE
pod/my-app-nginx-655b5cfc8c-mfhcb   1/1     Running   0          2m38s

NAME                   TYPE           CLUSTER-IP   EXTERNAL-IP     PORT(S)                      AGE
service/my-app-nginx   LoadBalancer   10.0.2.51    104.197.x.x   80:30291/TCP,443:31827/TCP   2m38s

NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/my-app-nginx   1/1     1            1           2m38s

NAME                                      DESIRED   CURRENT   READY   AGE
replicaset.apps/my-app-nginx-655b5cfc8c   1         1         1       2m38s
```
You can see the external IP of your application right there, but if you follow the instructions in the notes, you should see the same.

```
$ export SERVICE_IP=$(kubectl get svc --namespace default my-app-nginx --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")

$ echo "NGINX URL: http://$SERVICE_IP/"
NGINX URL: http://104.197.x.x/

$ curl $SERVICE_IP
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
```
You can see what releases are deployed with helm list.
```
NAME  	NAMESPACE	REVISION	UPDATED                            	STATUS  	CHART      	APP VERSION
my-app	default     	1       	2020-03-09 08:07:53.54657 -0400 EDT	deployed	nginx-5.1.9	1.16.1
```
It shows all the relevant information. Anytime you update a release, the revision number will increment. 

You can clean up by removing the app with uninstall.
```
$ helm uninstall my-app
release "my-app" uninstalled
```

### Changing the Values


Now you have a working nginx app but maybe you don't want it exposed externally via a load balancer. You can delete this app and redeploy it with `ClusterIP` instead of `LoadBalancer`.


Helm charts have a set of default values–the ones for this chart can be seen in [its GitHub repository](https://github.com/bitnami/charts/tree/master/bitnami/nginx). If you look there, you'll see the value you want to change is `service.type`. So you can now install that same chart using the `--set` flag to configure it.

```
$ helm install my-app bitnami/nginx --set service.type=ClusterIP
NAME: my-app
LAST DEPLOYED: Mon Mar 9 08:07:53 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Get the NGINX URL:

  echo "NGINX URL: http://127.0.0.1:8080/"
  kubectl port-forward --namespace blog svc/my-app-nginx 8080:80
```

Notice the `NOTES` section changed? It's a template too. You can see [here](https://github.com/bitnami/charts/blob/master/bitnami/nginx/templates/NOTES.txt#L25) that changing the service type changed the output.

In this instance you supplied the value via the CLI, but you could have also put it into a `values.yaml` file and used the `--values` CLI option. This is a common practice when you want to supply numerous values to the chart, and/or you want to keep track of what you're deploying by checking the file into a version control system. The easiest way to get started with your values file, is to download the default one from the chart repository, [like this one](https://github.com/bitnami/charts/blob/master/bitnami/nginx/values.yaml) for the nginx chart you deployed. Any value you aren't changing can be deleted from the file as it will be supplied by the default values.
If you wanted to do that to get the same results as above you'd create a `my-app-values.yaml` file with these contents:
```yaml
## NGINX Service properties
##
service:
  ## Service type
  ##
  type: ClusterIP
```
The command to create the release would then be:
````
$ helm install my-app bitnami/nginx --values my-app-values.yaml
````


### Upgrading a Release
Any time you want to change anything about a release-either a configuration value for the chart, upgrade the chart itself, or upgrade the application version, you'll run a `helm upgrade`.

For your nginx chart, you can show this by changing a configuration value. Currently the default image `pullPolicy` for this chart is `IfNotPresent`. You can change that to `Always` via an upgrade.

```yaml
$ helm upgrade my-app bitnami/nginx --set service.type=ClusterIP,image.pullPolicy=Always

Release "my-app" has been upgraded. Happy Helming!
NAME: my-app
LAST DEPLOYED: Wed Mar 11 13:50:05 2020
NAMESPACE: blog
STATUS: deployed
REVISION: 2
TEST SUITE: None
NOTES:
Get the NGINX URL:

  echo "NGINX URL: http://127.0.0.1:8080/"
  kubectl port-forward --namespace blog svc/my-app-nginx 8080:80
```
You can see the revision has been incremented. If you get the nginx pod you can see the change of configuration:
```yaml
$ kubectl get pod my-app-nginx-5bd7878597-pc8jp -o yaml

spec:
  containers:
  - image: docker.io/bitnami/nginx:1.16.1-debian-10-r46
    imagePullPolicy: Always
```
Why did you have to supply both `service.type` and `image.pullPolicy`? If you didn't supply both, the service type would have tried to revert to the default. 

### Rollback

What happens if you didn't want that change or it didn't work the way you expected? Remember the revision of the releases? You can rollback to a previous revision. You can do that here with `helm rollback`. If you want you can do a `--dry-run` first to see if the rollback would even work.
```
$ helm rollback my-app 1 --dry-run
Rollback was a success! Happy Helming!
$ helm rollback my-app 1
Rollback was a success! Happy Helming!
```
If you check the pod again, you'll see its back to `IfNotPreset` pullPolicy.

### Get Helming

If you're ready to start trying to deploy more charts, there are a whole bunch of charts available in a number of different repositories. A current list of repositories in a helm install might look like this:
```
NAME    	URL
stable  	https://kubernetes-charts.storage.googleapis.com
jetstack	https://charts.jetstack.io
elastic 	https://helm.elastic.co
bitnami 	https://charts.bitnami.com/bitnami
```

Happy Helming!